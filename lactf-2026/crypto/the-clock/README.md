# The Clock

## Summary

Challenge description: Don't run out of time

The challenge implements a Diffie–Hellman–style key exchange over a vulnerable custom algebraic group, followed by AES-ECB symmetric encryption of the flag. Due to the algebraic group chosen, an attacker can easily recover the prime $p$ and also brute-force compute either of Alice or Bob's secrets in order to decrypt the flag.

**Artifacts:**

- `chall.py`: implementation of vulnerable encryption scheme, chosen prime $p$ is redacted
- `solve.py`: python script to solve the challenge
- `output.txt`: output generated by `chall.py`
- `challenge.yaml`: challenge metadata file, including flag

## Context

The challenge author *freed* provides the [source code](./chall.py) of the key exchange, with the (typically public) modulus prime $p$ redatected, as well as an [output](./output.txt) containing Alice and Bob's public keys and the encrypted flag produced by the source code.

Initially, the key exchange seems to possibly be ECDH, because addition and scalar multiplication operations are defined for points over a field. Below is how the code defines the finite field $\mathbb{F}_p=\mathbb{Z}/p\mathbb{Z}$. Everything is intuitive besides the division operation, which is implemented based on Fermat's Little Theorem where for non-zero $x$ and prime $p$, $x^{p} \equiv x \pmod{p} \implies x^{p-1}\equiv 1 \pmod{p} \implies x^{p-2} \equiv x^{-1}\pmod{p}$ and $a / b \equiv a \cdot b^{-1} \pmod{p}$,

```python
def F(p):
  # caveat: caller must ensure that p is prime
  class F:
    def __init__(self,x):
      self.int = x % p
    def __str__(self):
      return str(self.int)
    __repr__ = __str__
    def __eq__(a,b):
      return a.int == b.int
    def __ne__(a,b):
      return a.int != b.int
    def __add__(a,b):
      return F(a.int + b.int)
    def __sub__(a,b):
      return F(a.int - b.int)
    def __mul__(a,b):
      return F(a.int * b.int)
    def __div__(a,b):
      # caveat: caller must ensure that b is nonzero
      return a*F(pow(b.int,p-2,p))
  return F
```

However, the group law `clockadd` is not addition of points on an elliptic curve, instead it is actually complex multiplication. If we interpret each point $(x,y)$ as representing the complex number $y + ix$, then $(y_1 + ix_1)(y_2 + ix_2)=(y_{1}y_{2}-x_{1}x_{2}, x_{1}y_{2}+y_{1}x_{2})$.

```python
def clockadd(P1,P2):
  x1,y1 = P1
  x2,y2 = P2
  x3 = x1*y2+y1*x2
  y3 = y1*y2-x1*x2
  return x3,y3
```

Since the "addition" operation is multiplication, we seemingly have a multiplicative group. This is confirmed by the scalar "multiplication" operation, which is actually just exponentiation--note that (0,1) is the multiplicative identity.

```python
def scalarmult(P, n):
  # caveat: caller must ensure that n is nonnegative
  # caveat: n is limited by python's recursion limit
  if n == 0: return (Fp(0),Fp(1))
  if n == 1: return P
  Q = scalarmult(P, n//2)
  Q = clockadd(Q,Q)
  if n % 2: Q = clockadd(P,Q)
  return Q
```

## Vulnerability

The fundamental vulnerability is that the points of the algebraic group must satisfy $x^2 + y^2 = 1$, and therefore the group order must either be $p+1$ or $p-1$ depending on if $p \equiv 3 \pmod{4}$. The group order for the prime chosen ends up being $p+1$ which is very smooth. The smoothness makes the discrete log problem easy with the **Pohlig-Hellman** attack.

Of course, this requires us knowing $p$, which while typically is public information in this case it is not. However, $p$ is actually quite easy to recover. This is because we know that the group must be closed under `clockadd` and `scalarmult` to ensure correctness, i.e., the norm must be constant under these operations. For $z=y+xi$, $N(z) = x^{2} + y^{2}$. Suppose we restrict the norm to $N(z) = c$. If we `clockadd` two points, we will have the following:

$$N(z_1)=x_1^2 + y_1^2 = c$$
$$N(z_2)= x_2^2 + y_2^2 = c$$
$$N(z_1z_2) = (y_{1}y_{2}-x_{1}x_{2})^2 + (x_{1}y_{2}+y_{1}x_{2})^2$$
$$N(z_1z_2) = \left((y_1y_2)^2 - 2y_1y_2x_1x_2 + (x_1x_2)^2\right) + \left((x_1y_2)^2+2x_1y_2y_1x_2 + (y_1x_2)^2\right)$$
$$N(z_1z_2) = (y_1y_2)^2  + (x_1x_2)^2 + (x_1y_2)^2 + (y_1x_2)^2$$
$$N(z_1z_2) = x_1^2(y_2^2+x_2^2) + y_1^2(y_2^2+x_2^2)$$
$$N(z_1z_2) = (x_1^2 + y_1^2)(x_2^2 + y_2^2)$$
$$N(z_1z_2) = c^2$$


Thus, in order for the norm to remain constant $c=c^2 \implies c=1$. We now know that $x^2 + y^2 = 1$, which means that all points must lie on the unit circle, hence the name `clockadd`. With this, we know that $x^2 + y^2 - 1 \equiv 0 \pmod {p}$, which means that the prime $p$ divides $x^2 + y^2 - 1$ for any valid point. Thus, we can recover $p$ by computing the gcd of the base pase point, Alice's public point, and Bob's public point.

This vulnerability would fall under [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html).

## Exploitation

The below steps are implemented in [solve.py](./solve.py):

1. Recover prime $p$ by computing `p = gcd(base_point, alice_public, bob_public)`/
2. Recover either private key by "solving" the DLP by exploiting the smoothness of the group order with the Pohlig-Hellman attack.
3. Use either private key to compute shared secret symmetric key.
4. Decrypt the flag with recovered symmetric key.

## Remediation

Don't define your own custom algebraic group with known group order for the basis of your encryption, but if you do, ensure that the group order is not smooth! In general, don't define your own custom diffie-hellman; instead use ECC standards such as X25519 or P-256.
