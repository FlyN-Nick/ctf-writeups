# The Clock

## Summary

Challenge description: Don't run out of time

The challenge implements a Diffie–Hellman–style key exchange over a vulnerable custom algebraic group, followed by AES-ECB symmetric encryption of the flag. Due to the algebraic group chosen, an attacker can easily recover the prime $p$ and efficiently compute either of Alice or Bob's secrets in order to decrypt the flag.

**Artifacts:**

- `chall.py`: implementation of vulnerable encryption scheme, chosen prime $p$ is redacted
- `solve.py`: python script to solve the challenge
- `output.txt`: output generated by `chall.py`
- `challenge.yaml`: challenge metadata file, including flag

## Context

The challenge author *freed* provides the [source code](./chall.py) of the key exchange, with the (typically public) modulus prime $p$ redacted, as well as an [output](./output.txt) containing Alice and Bob's public keys and the encrypted flag produced by the source code.

Initially, the key exchange seems to possibly be ECDH, because addition and scalar multiplication operations (`clock_add` and `scalarmult`) are defined for points over a field, and the public keys are generated by choosing a random secret integer $k$ and multiplying a known base point $k$ times. Below is how the code defines the finite field $\mathbb{F}_p=\mathbb{Z}/p\mathbb{Z}$. Besides division, everything is simply defined as their integer operation equivalents mod $p$. The division operation is implemented based on Fermat's Little Theorem where for non-zero $x$ and prime $p$, $x^{p} \equiv x \pmod{p} \implies x^{p-1}\equiv 1 \pmod{p} \implies x^{p-2} \equiv x^{-1}\pmod{p}$ and $a / b \equiv a \cdot b^{-1} \pmod{p}$,

```python
def F(p):
  # caveat: caller must ensure that p is prime
  class F:
    def __init__(self,x):
      self.int = x % p
    def __str__(self):
      return str(self.int)
    __repr__ = __str__
    def __eq__(a,b):
      return a.int == b.int
    def __ne__(a,b):
      return a.int != b.int
    def __add__(a,b):
      return F(a.int + b.int)
    def __sub__(a,b):
      return F(a.int - b.int)
    def __mul__(a,b):
      return F(a.int * b.int)
    def __div__(a,b):
      # caveat: caller must ensure that b is nonzero
      return a*F(pow(b.int,p-2,p))
  return F
```

However, the group law `clockadd` is not addition of points on an elliptic curve, instead it is actually complex multiplication. If we interpret each point $(x,y)$ as representing the complex number $y + ix$, then $(y_1 + ix_1)(y_2 + ix_2)=(y_{1}y_{2}-x_{1}x_{2}, x_{1}y_{2}+y_{1}x_{2})$.

```python
def clockadd(P1,P2):
  x1,y1 = P1
  x2,y2 = P2
  x3 = x1*y2+y1*x2
  y3 = y1*y2-x1*x2
  return x3,y3
```

Since the "addition" operation is multiplication, we seemingly have a multiplicative group. This is confirmed by the scalar "multiplication" operation, which is actually just exponentiation--note that (0,1) is the multiplicative identity.

```python
def scalarmult(P, n):
  # caveat: caller must ensure that n is nonnegative
  # caveat: n is limited by python's recursion limit
  if n == 0: return (Fp(0),Fp(1))
  if n == 1: return P
  Q = scalarmult(P, n//2)
  Q = clockadd(Q,Q)
  if n % 2: Q = clockadd(P,Q)
  return Q
```

## Vulnerability

The fundamental vulnerability is that the points of the algebraic group must satisfy $x^2 + y^2 = 1$ in order to ensure the required property of closure. This vulnerability has two consequences. First, it allows us to easily deduce the prime $p$ using gcd. Second, it causes a known group order which happens to be very smooth (it factorizes into small primes). With this known smooth group order, the discrete log problem can be reduced into multiple smaller, manageable DLPs with the **Pohlig-Hellman** attack.

We know that in order to ensure correctness, the subgroup generated by the base point must be closed under `clockadd` and `scalarmult`, i.e., the norm must be constant under its operations. For $z=y+xi$, $N(z) = x^{2} + y^{2}$. Suppose we restrict the norm to $N(z) = c$. If we `clockadd` two points, we will have the following:

$$
N(z_1)=x_1^2 + y_1^2 = c
$$

$$
N(z_2)= x_2^2 + y_2^2 = c
$$

$$
N(z_1z_2) = (y_{1}y_{2}-x_{1}x_{2})^2 + (x_{1}y_{2}+y_{1}x_{2})^2
$$

$$
N(z_1z_2) = \left((y_1y_2)^2 - 2y_1y_2x_1x_2 + (x_1x_2)^2\right) + \left((x_1y_2)^2+2x_1y_2y_1x_2 + (y_1x_2)^2\right)
$$

$$
N(z_1z_2) = (y_1y_2)^2  + (x_1x_2)^2 + (x_1y_2)^2 + (y_1x_2)^2
$$

$$
N(z_1z_2) = x_1^2(y_2^2+x_2^2) + y_1^2(y_2^2+x_2^2)
$$

$$
N(z_1z_2) = (x_1^2 + y_1^2)(x_2^2 + y_2^2)
$$

$$
N(z_1z_2) = c^2
$$

Thus, in order for the norm to remain constant $c=c^2 \implies c=1$. We now know that $x^2 + y^2 = 1$, which means that all points must lie on the unit circle, hence the name `clockadd`. With this, we know that $x^2 + y^2 - 1 \equiv 0 \pmod {p}$, which means that the prime $p$ divides $x^2 + y^2 - 1$ for any valid point. Computing the gcd of the values $x^2+y^2-1$ for the base point, Alice's public point, and Bob's public point will either give us $p$ or a small multiple of $p$, recovering the prime.

Furthermore, since all points of the algebraic group must satisfy $x^2 + y^2 = 1$, the group order must either be $p+1$ or $p-1$ depending on if $p \equiv 3 \pmod{4}$. The group order for the prime chosen ends up being $p+1$ which is very smooth (it factorizes into small primes). The smoothness makes the discrete log problem easy with the **Pohlig-Hellman** attack, where these smaller discrete logs are computed and then combined with the Chinese Remainder Theorem.

This vulnerability would fall under [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html).

## Exploitation

The below steps are implemented in [solve.py](./solve.py):

1. Recover prime $p$ by computing $p = \text{gcd}(x_{\text{base}}^2 + y_{\text{base}}^2 - 1, x_{\text{alice}}^2 + y_{\text{alice}}^2 - 1, x_{\text{bob}}^2 + y_{\text{bob}}^2 - 1)$.

   ```python
   def recover_prime(points):
       """Recover p from the public points by computing gcd of x^2+y^2-1."""
       candidates = [x * x + y * y - 1 for x, y in points]
       return reduce(gcd, candidates)

   p = recover_prime([BASE, ALICE_PUB, BOB_PUB])
   ```
2. Recover either Alice's or Bob's private key by "solving" the DLP by exploiting the smoothness of the group order with the Pohlig-Hellman attack.

   1. Factor the group order into its prime power factors with trial division.

   ```python
   def factorize_smooth(n):
       """Trial-division factorization. Fast here because p+1 is very smooth."""
       factors = {}
       while n % 2 == 0:
           factors[2] = factors.get(2, 0) + 1
           n //= 2

       d = 3
       lim = isqrt(n)
       while d <= lim and n > 1:
           while n % d == 0:
               factors[d] = factors.get(d, 0) + 1
               n //= d
               lim = isqrt(n)
           d += 2

       if n > 1:
           factors[n] = factors.get(n, 0) + 1
       return factors
   ```

   2. For each prime power dividing the group order, compute the discrete log mod that prime power by brute force with the baby-step giant-step algorithm.

   The baby-step giant-step algorithm is a time-memory tradeoff algorithm for brute-force solving the DLP. Typically, solving DLP with a naive brute-force approach would require $O(n)$ time where $n$ is the group order, but with baby-step giant-step, we can solve it in $O(\sqrt{n})$ time and space. The algorithm rewrites the exponent $x$ as $x=im + j$, where $m=\lceil \sqrt{n} \rceil$ and $0 \leq i, j < m$. We can then precompute a "baby-step" table of $g^j$ for $0 \leq j < m$. Then, we can compute the "giant-steps" of $h g^{-im}$ for $0 \leq i < m$ and check if any of these values are in the baby-step table. If we find a match, then we have $h g^{-im} = g^j \implies h = g^{im+j}$, so we can return $x=im+j$.

   ```python
   def dlog_bsgs(H, G, n, p):
       """Solve x such that H = x*G in subgroup of order n using Baby-step Giant-step algorithm."""
       m = isqrt(n) + 1
       cur = (0, 1)
       baby_steps = {cur: 0}
       for j in range(1, m):
           cur = clock_add(cur, G, p)
           if cur not in baby_steps:
               baby_steps[cur] = j

       neg_mG = scalar_mult(G, n - m, p)

       gamma = H
       for i in range(m):
           j = baby_steps.get(gamma)
           if j is not None:
               return (i * m + j) % n
           gamma = clock_add(gamma, neg_mG, p)
       raise ValueError("No discrete log found.")
   ```

   3. Combine the results with the Chinese Remainder Theorem to get the private key.

      For simplicity, we implement the CRT for two pairs and then use it iteratively to combine all pairs. We are solving for $x$ such that $x \equiv a_1 \pmod{m_1}$ and $x \equiv a_2 \pmod{m_2}$ where $m_1$ and $m_2$ are coprime. We are looking for a solution of the form $x = a_1 + m_1 t$ for some integer $t$, because a solution of this form will satisfy the first congruence. We can then substitute this into the second congruence to get $a_1 + m_1 t \equiv a_2 \pmod{m_2}$. Rearranging gives $m_1 t \equiv a_2 - a_1 \pmod{m_2}$. Since $m_1$ and $m_2$ are coprime, we can compute the inverse of $m_1$ mod $m_2$, denoted as $m^{-1}$, and multiply both sides by this inverse to get $t \equiv (a_2 - a_1) \cdot m^{-1} \pmod{m_2}$. We can then substitute back to get $x \equiv a_1 + m_{1}t \pmod{m_1 \cdot m_2}$

   ```python
   def crt_pair(a1, m1, a2, m2):
       """Solve x ≡ a1 (mod m1) and x ≡ a2 (mod m2) for coprime m1, m2 with Chinese Remainder Theorem."""
       inv = pow(m1, -1, m2)
       t = ((a2 - a1) * inv) % m2
       x = a1 + m1 * t
       return x % (m1 * m2), m1 * m2

   def crt_all(remainders, moduli):
       """Solve x ≡ a (mod m) for all (a, m) pairs with Chinese Remainder Theorem."""
       x, m = remainders[0], moduli[0]
       for a, mod in zip(remainders[1:], moduli[1:]):
           x, m = crt_pair(x, m, a, mod)
       return x

   def pohlig_hellman_two_targets(p_base, p_alice, p_bob, group_order, p):
       """Solve for x1, x2 such that p_alice = x1 * p_base and p_bob = x2 * p_base using Pohlig-Hellman attack."""
       prime_power_factors = factorize_smooth(group_order)
       moduli = []
       remainders_alice = []
       remainders_bob = []

       for prime_factor, exponent in prime_power_factors.items():
           prime_power = prime_factor ** exponent
           p_base_reduced = scalar_mult(p_base, group_order // prime_power, p)
           p_alice_reduced = scalar_mult(p_alice, group_order // prime_power, p)
           p_bob_reduced = scalar_mult(p_bob, group_order // prime_power, p)
           x1 = dlog_bsgs(p_alice_reduced, p_base_reduced, prime_power, p)
           x2 = dlog_bsgs(p_bob_reduced, p_base_reduced, prime_power, p)
           moduli.append(prime_power)
           remainders_alice.append(x1)
           remainders_bob.append(x2)

       return crt_all(remainders_alice, moduli), crt_all(remainders_bob, moduli)
   ```

3. Use either private key to compute shared secret symmetric key.

   ```python
   shared = scalar_mult(BOB_PUB, alice_secret, p)
   key = md5(f"{shared[0]},{shared[1]}".encode()).digest()
   ```

4. Decrypt the flag with recovered symmetric key.

   ```python
   pt = AES.new(key, AES.MODE_ECB).decrypt(enc)
   flag = unpad(pt, 16).decode()
   ```

## Remediation

Don't define your own custom algebraic group with known group order for the basis of your encryption, but if you do, ensure that the group order is not smooth! In general, don't define your own custom diffie-hellman; instead use ECC standards such as X25519 or P-256.
